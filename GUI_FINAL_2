import tkinter as tk
from tkinter import scrolledtext, messagebox
import sqlite3
import requests
import cv2
import numpy as np
from PIL import Image, ImageTk

API_URL = "http://192.168.240.123"


def init_db():
    with sqlite3.connect("users.db") as db:
        db.execute(
            """CREATE TABLE IF NOT EXISTS Users (
                UserID INTEGER PRIMARY KEY AUTOINCREMENT,
                Username TEXT UNIQUE,
                Password TEXT
            )"""
        )


def reparameterize_curve(points, num_points=200):
    points = np.asarray(points)
    if len(points) < 2:
        return points

    seg = np.diff(points, axis=0)
    seg_len = np.sqrt((seg * seg).sum(axis=1))
    arc = np.concatenate(([0.0], np.cumsum(seg_len)))
    total = arc[-1]

    if total == 0:
        return points

    t = arc / total
    t_new = np.linspace(0.0, 1.0, num_points)

    x_new = np.interp(t_new, t, points[:, 0])
    y_new = np.interp(t_new, t, points[:, 1])
    return np.column_stack((x_new, y_new))

def process_frame(frame):
    h, w = frame.shape[:2]

    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    gray_blur = cv2.GaussianBlur(gray, (5, 5), 0)

    inv = cv2.bitwise_not(gray_blur)

    kx = max(15, w // 30)   # horizontal line length
    ky = max(15, h // 30)   # vertical line length

    horiz_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (kx, 1))
    vert_kernel  = cv2.getStructuringElement(cv2.MORPH_RECT, (1, ky))

    horiz_lines = cv2.morphologyEx(inv, cv2.MORPH_OPEN, horiz_kernel, iterations=1)
    vert_lines  = cv2.morphologyEx(inv, cv2.MORPH_OPEN, vert_kernel, iterations=1)

    grid = cv2.bitwise_or(horiz_lines, vert_lines)

    _, mask = cv2.threshold(grid, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    mask = cv2.dilate(mask, cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3)), iterations=1)

    gray_clean = cv2.inpaint(gray_blur, mask, 3, cv2.INPAINT_TELEA)
    edges = cv2.Canny(gray_clean, 40, 130)

    edges = cv2.morphologyEx(
        edges,
        cv2.MORPH_CLOSE,
        cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5)),
        iterations=1,
    )

    contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    min_area = 150
    max_area = 0.45 * h * w

    def contour_ok(cnt):
        area = cv2.contourArea(cnt)
        if area < min_area or area > max_area:
            return False
        x, y, cw, ch = cv2.boundingRect(cnt)
        if ch == 0 or cw == 0:
            return False
        ar = cw / ch
        return 0.1 < ar < 10

    candidates = [c for c in contours if contour_ok(c)]
    if len(candidates) < 2:
        return frame

    candidates.sort(key=cv2.contourArea, reverse=True)
    c1, c2 = candidates[0], candidates[1]

    def ordered_points(cnt):
        pts = cnt.reshape(-1, 2)
        x, y, cw, ch = cv2.boundingRect(cnt)
        axis = 0 if cw > ch else 1
        return pts[np.argsort(pts[:, axis])]

    n = 500
    curve1 = reparameterize_curve(ordered_points(c1), n)
    curve2 = reparameterize_curve(ordered_points(c2), n)
    center = (curve1 + curve2) / 2.0

    def to_polyline(arr):
        return arr.astype(np.int32).reshape((-1, 1, 2))

    # Draw results
    cv2.polylines(frame, [to_polyline(center)], False, (0, 0, 255), 6)
    cv2.polylines(frame, [to_polyline(curve1)], False, (255, 0, 0), 2)
    cv2.polylines(frame, [to_polyline(curve2)], False, (0, 255, 255), 2)

    return frame


class LoginWindow:
    def __init__(self, root):
        self.root = root
        self.root.title("Login System")
        self.root.geometry("300x200")

        tk.Label(root, text="Username").pack(pady=5)
        self.entry_user = tk.Entry(root)
        self.entry_user.pack()

        tk.Label(root, text="Password").pack(pady=5)
        self.entry_pass = tk.Entry(root, show="*")
        self.entry_pass.pack()

        tk.Button(root, text="Login", command=self.login).pack(pady=5)
        tk.Button(root, text="Register", command=self.register).pack(pady=5)

    def register(self):
        u, p = self.entry_user.get(), self.entry_pass.get()
        if not u or not p:
            messagebox.showwarning("Error", "Enter both username and password")
            return
        try:
            with sqlite3.connect("users.db") as db:
                db.execute("INSERT INTO Users (Username, Password) VALUES (?, ?)", (u, p))
            messagebox.showinfo("Success", "User registered!")
        except:
            messagebox.showerror("Error", "Username already exists")

    def login(self):
        u, p = self.entry_user.get(), self.entry_pass.get()
        with sqlite3.connect("users.db") as db:
            cur = db.execute("SELECT * FROM Users WHERE Username=? AND Password=?", (u, p))
        if cur.fetchone():
            messagebox.showinfo("Welcome", f"Hello {u}!")
            self.root.destroy()
            open_robot_gui()
        else:
            messagebox.showerror("Error", "Invalid login")


class RobotGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Robot Controller")
        self.root.geometry("1920x1080")

        for r in range(2):
            self.root.grid_rowconfigure(r, weight=1, uniform="row")
        for c in range(2):
            self.root.grid_columnconfigure(c, weight=1, uniform="col")

        # --- TOP LEFT (RAW CAMERA) ---
        frame_top_left = tk.Frame(root, bg="black")
        frame_top_left.grid(row=0, column=0, sticky="nsew")
        self.raw_label = tk.Label(frame_top_left, bg="black")
        self.raw_label.pack(expand=True, fill="both")

        # --- BOTTOM LEFT (PROCESSED CAMERA) ---
        frame_bottom_left = tk.Frame(root, bg="gray20")
        frame_bottom_left.grid(row=1, column=0, sticky="nsew")
        self.proc_label = tk.Label(frame_bottom_left, bg="gray20")
        self.proc_label.pack(expand=True, fill="both")

        # --- TOP RIGHT (CONTROLS) ---
        frame_top_right = tk.Frame(root, bg="lightblue")
        frame_top_right.grid(row=0, column=1, sticky="nsew")
        frame_top_right.grid_rowconfigure((0, 1, 2), weight=1)
        frame_top_right.grid_columnconfigure((0, 1, 2), weight=1)

        buttons = {
            "↑": ("forward", 0, 1),
            "↓": ("backward", 2, 1),
            "←": ("left", 1, 0),
            "→": ("right", 1, 2),
            "▶ Play": ("start", 1, 1),
            "■ Stop": ("stop", 1, 1),
        }

        for text, (cmd, r, c) in buttons.items():
            tk.Button(
                frame_top_right,
                text=text,
                width=8 if " " in text else 5,
                height=2,
                command=lambda e=cmd: self.send_command(e),
                fg="green" if "Play" in text else ("red" if "Stop" in text else "black"),
            ).grid(row=r, column=c, padx=5, pady=5, sticky="nsew")

        # --- BOTTOM RIGHT (LOG) ---
        frame_bottom_right = tk.Frame(root, bg="white")
        frame_bottom_right.grid(row=1, column=1, sticky="nsew")

        tk.Label(frame_bottom_right, text="User Log", font=("Arial", 14)).pack(anchor="nw")
        self.log_box = scrolledtext.ScrolledText(
            frame_bottom_right, wrap=tk.WORD, width=60, height=20
        )
        self.log_box.pack(expand=True, fill="both", padx=10, pady=10)

        self.add_log("System Ready.")

        self.cap = cv2.VideoCapture(0)
        self._after_id = None
        self._update_streams()

        self.root.protocol("WM_DELETE_WINDOW", self._on_close)

    def _update_streams(self):
        if not self.cap or not self.cap.isOpened():
            self._after_id = self.root.after(500, self._update_streams)
            return

        ok, frame = self.cap.read()
        if ok:
            # raw
            raw_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            raw_imgtk = ImageTk.PhotoImage(Image.fromarray(raw_rgb))
            self.raw_label.configure(image=raw_imgtk)
            self.raw_label.image = raw_imgtk

            # processed
            processed = process_frame(frame.copy())
            proc_rgb = cv2.cvtColor(processed, cv2.COLOR_BGR2RGB)
            proc_imgtk = ImageTk.PhotoImage(Image.fromarray(proc_rgb))
            self.proc_label.configure(image=proc_imgtk)
            self.proc_label.image = proc_imgtk

        self._after_id = self.root.after(15, self._update_streams)

    def _on_close(self):
        if self._after_id is not None:
            try:
                self.root.after_cancel(self._after_id)
            except:
                pass
            self._after_id = None

        if getattr(self, "cap", None) is not None:
            try:
                self.cap.release()
            except:
                pass
            self.cap = None

        self.root.destroy()

    def send_command(self, cmd):
        try:
            res = requests.get(f"{API_URL}/{cmd}")
            if res.ok:
                self.add_log(res.json().get("message", "No response"))
            else:
                self.add_log(f"Error {res.status_code}")
        except Exception as e:
            self.add_log(f"API Error: {e}")

    def add_log(self, msg):
        self.log_box.insert(tk.END, msg + "\n")
        self.log_box.see(tk.END)


def open_robot_gui():
    r = tk.Tk()
    app = RobotGUI(r)
    r.mainloop()


if __name__ == "__main__":
    init_db()
    root = tk.Tk()
    login_app = LoginWindow(root)
    root.mainloop()

